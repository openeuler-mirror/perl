From 9d890beed61e079102335ef5859d652b4e2c32ac Mon Sep 17 00:00:00 2001
From: Chris 'BinGOs' Williams <chris@bingosnet.co.uk>
Date: Mon, 20 Aug 2018 11:15:20 +0100
Subject: [PATCH] Update Time-Piece to CPAN version 1.33

  [DELTA]

1.33    2018-08-18
        - Allow objects in overloaded methods
---
 Porting/Maintainers.pl         |  2 +-
 cpan/Time-Piece/Piece.pm       | 40 ++++++++++++++++++++--------------
 cpan/Time-Piece/Seconds.pm     |  2 +-
 cpan/Time-Piece/t/06subclass.t | 15 +++++++++++++
 4 files changed, 41 insertions(+), 18 deletions(-)

diff --git a/Porting/Maintainers.pl b/Porting/Maintainers.pl
index eaf9ed3262..a137ee9483 100755
--- a/Porting/Maintainers.pl
+++ b/Porting/Maintainers.pl
@@ -1208,7 +1208,7 @@ use File::Glob qw(:case);
     },
 
     'Time::Piece' => {
-        'DISTRIBUTION' => 'ESAYM/Time-Piece-1.3204.tar.gz',
+        'DISTRIBUTION' => 'ESAYM/Time-Piece-1.33.tar.gz',
         'FILES'        => q[cpan/Time-Piece],
         'EXCLUDED'     => [ qw[reverse_deps.txt] ],
     },
diff --git a/cpan/Time-Piece/Piece.pm b/cpan/Time-Piece/Piece.pm
index 8acba86e76..d5624636c6 100644
--- a/cpan/Time-Piece/Piece.pm
+++ b/cpan/Time-Piece/Piece.pm
@@ -6,6 +6,7 @@ use XSLoader ();
 use Time::Seconds;
 use Carp;
 use Time::Local;
+use Scalar::Util qw/ blessed /;
 
 use Exporter ();
 
@@ -18,7 +19,7 @@ our %EXPORT_TAGS = (
     ':override' => 'internal',
     );
 
-our $VERSION = '1.3204';
+our $VERSION = '1.33';
 
 XSLoader::load( 'Time::Piece', $VERSION );
 
@@ -63,13 +64,27 @@ sub gmtime {
     $class->_mktime($time, 0);
 }
 
+
+# Check if the supplied param is either a normal array (as returned from
+# localtime in list context) or a Time::Piece-like wrapper around one.
+#
+# We need to differentiate between an array ref that we can interrogate and
+# other blessed objects (like overloaded values).
+sub _is_time_struct {
+    return 1 if ref($_[1]) eq 'ARRAY';
+    return 1 if blessed($_[1]) && $_[1]->isa('Time::Piece');
+
+    return 0;
+}
+
+
 sub new {
     my $class = shift;
     my ($time) = @_;
 
     my $self;
 
-    if (ref($time)) {
+    if ($class->_is_time_struct($time)) {
         $self = $time->[c_islocal] ? $class->localtime($time) : $class->gmtime($time);
     }
     elsif (defined($time)) {
@@ -106,10 +121,9 @@ sub parse {
 sub _mktime {
     my ($class, $time, $islocal) = @_;
 
-    $class = eval { (ref $class) && (ref $class)->isa('Time::Piece') }
-           ? ref $class
-           : $class;
-    if (ref($time)) {
+    $class = blessed($class) || $class;
+
+    if ($class->_is_time_struct($time)) {
         my @new_time = @$time;
         my @tm_parts = (@new_time[c_sec .. c_mon], $new_time[c_year]+1900);
         $new_time[c_epoch] = $islocal ? timelocal(@tm_parts) : timegm(@tm_parts);
@@ -639,7 +653,8 @@ sub cdate {
 
 sub str_compare {
     my ($lhs, $rhs, $reverse) = @_;
-    if (UNIVERSAL::isa($rhs, 'Time::Piece')) {
+
+    if (blessed($rhs) && $rhs->isa('Time::Piece')) {
         $rhs = "$rhs";
     }
     return $reverse ? $rhs cmp $lhs->cdate : $lhs->cdate cmp $rhs;
@@ -652,9 +667,6 @@ use overload
 sub subtract {
     my $time = shift;
     my $rhs = shift;
-    if (UNIVERSAL::isa($rhs, 'Time::Seconds')) {
-        $rhs = $rhs->seconds;
-    }
 
     if (shift)
     {
@@ -667,7 +679,7 @@ sub subtract {
 	return $rhs - "$time";
     }
 
-    if (UNIVERSAL::isa($rhs, 'Time::Piece')) {
+    if (blessed($rhs) && $rhs->isa('Time::Piece')) {
         return Time::Seconds->new($time->epoch - $rhs->epoch);
     }
     else {
@@ -679,10 +691,6 @@ sub subtract {
 sub add {
     my $time = shift;
     my $rhs = shift;
-    if (UNIVERSAL::isa($rhs, 'Time::Seconds')) {
-        $rhs = $rhs->seconds;
-    }
-    croak "Invalid rhs of addition: $rhs" if ref($rhs);
 
     return $time->_mktime(($time->epoch + $rhs), $time->[c_islocal]);
 }
@@ -692,7 +700,7 @@ use overload
 
 sub get_epochs {
     my ($lhs, $rhs, $reverse) = @_;
-    if (!UNIVERSAL::isa($rhs, 'Time::Piece')) {
+    unless (blessed($rhs) && $rhs->isa('Time::Piece')) {
         $rhs = $lhs->new($rhs);
     }
     if ($reverse) {
diff --git a/cpan/Time-Piece/Seconds.pm b/cpan/Time-Piece/Seconds.pm
index 3a56b74485..71a4bd27f2 100644
--- a/cpan/Time-Piece/Seconds.pm
+++ b/cpan/Time-Piece/Seconds.pm
@@ -1,7 +1,7 @@
 package Time::Seconds;
 use strict;
 
-our $VERSION = '1.3204';
+our $VERSION = '1.33';
 
 use Exporter 5.57 'import';
 
diff --git a/cpan/Time-Piece/t/06subclass.t b/cpan/Time-Piece/t/06subclass.t
index d6e4315c8f..a72cfb89ac 100644
--- a/cpan/Time-Piece/t/06subclass.t
+++ b/cpan/Time-Piece/t/06subclass.t
@@ -35,6 +35,21 @@ for my $method (qw(new localtime gmtime)) {
   isa_ok($diff, $class, "yesterday via subtraction operator");
 }
 
+{
+  my $g = $class->gmtime;
+  my $l = $class->localtime;
+
+  #via clone
+  my $l_clone = $class->new($l);
+  isa_ok($l_clone, $class, 'custom localtime via clone');
+  cmp_ok("$l_clone", 'eq', "$l", 'Clones match');
+
+  #via clone with gmtime
+  my $g_clone = $class->new($g);
+  isa_ok($g_clone, $class, 'custom gmtime via clone');
+  cmp_ok("$g_clone", 'eq', "$g", 'Clones match');
+}
+
 {
   # let's verify that we can use gmtime from T::P without the export magic
   my $piece = Time::Piece::gmtime;
-- 
2.19.1

